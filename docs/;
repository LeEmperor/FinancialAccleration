

\documentclass[12pt]{article}


\usepackage{parskip}
\usepackage{setspace}

\onehalfspacing

\begin{document}


\begin{titlepage}
  \centering
  {\Huge\bfseries Dorm Room \par High-Frequency Trading \par} % Title
  \vspace{.5cm}
  {\Large University of Florida \par}
  \vspace{2cm}
  {\Large Concept Exploratory \par}
  \vspace{1.5cm}
  {\large Bo Purtell \par}
  \vspace{2cm}
  % {\large \today \par}
  {\large August 27, 2025\par}
\end{titlepage}

% --------------------------------------------------------
\section*{Executive Summary}
% 4 parts, each with unique challenges and implementation expertises

\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Motivations}
Quant jobs make alot of money. I like money. 
I also like hard things \emph{wink.}

And people pay alot of money for hard things to be done. Thus is follows that if I follow the money, I will find hard things to do.

So who pays alot? Banks pay alot.
But why would a bank want an engineer?
You'd be surprised.

Quant traders are a subset of traders that use advanced math and computing algorithms to power their decision making.
But with what tools and data do they make these trades? Their trusty computer models and algorithms.
\\ This of course opens the realm of low-latency systems in finance - most often engineered in C++.
These systems are known to be insanely fast.

But do you know what's faster than software? \\ Hardware.

So this set's the stage: Designing ultra-fast systems that deal with high levels of precision and insane throughput rates.
Seconds cost millions. 
\newline
Our Mission: 
\begin{itemize}
  \item Process data from the exchange
  \item Make decisions as fast as possible
  \item Send our decisions (buy/sell orders) back to the exchange
  \item Optional: Try not to fuck up too much: Mistakes cost billions 
\end{itemize}

Insanely difficult.
Niche of the niche.
Razorthin margins.
\\ So how do we go about learning how these systems work? 
\newline
\\ \textbf{\emph{We make one}}.

\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Problem Statement}
% how to do HFT stuff without HFT stuff

Given the dominance of special firms that make use of this framework to improve their edge through specialized hardware, optimized networks, and low-latency algorithms, we must now find a way to mimic this infastructure. 

While this setup may sound easy on paper, there is a significant barrier to entry for smaller entities including small firms, independent developers, and academic researchers like ourselves who lack expensive resources.

This presents three (3) key challenges: 
\begin{enumerate}
  \item \textbf{Technical Complexity} - High-Frequency Trading (HFT) platforms require highly specialized engineering skills across networking, FPGA design, and distrbuted systems. On their own these are already niche enough subjects, but when combined result in nothing short of a steep learning curve before even basic trading strategies can be protoyped.
  \item \textbf{Resource Inequality} - Colocated servers, FPGA accelerators/boards, and expensive networking equipment  and expensive networking equipment  and expensive networking equipment  and expensive enterprise-grade networking equipment limit participation in these markets to well-funded institutions - often excluding smaller players.
  \item \textbf{Data Scarcity} - Getting ahold of generic stock-market data is easy enough with frameworks such as PolygonAPI and YahooFinance, yet sufficiently granular tick-level data is prohibitively expensive or outright unavailable as many providers provide delayed or aggregated feeds leaving sub-millisecond strategies nearly impossible. 
\end{enumerate}

As a result, innovation is slowed; and promising ideas from individuals or startups are often left unexplored.
But do we really care? \\ No. We just want to prove we have the skills to run with the big leagues.
\\
So it's \textbf{\emph{hard}}, it's \textbf{\emph{expensive}}, and premium gasoline is \textbf{\emph{scarce}}. What to do...
\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Approach}

We wouldn't be here if we thought that some part of this \emph{wasn't} \textbf{un}achieveable. So how do we solve complexity? By cutting things up.
\subsection*{(4) Essential Components}

\paragraph {1. An Exchange}\

We don't have an exchange. So let's make one.

Or at least something that behaves like one. We don't need real-time data; just enough data over a given timeframe that demonstrates our system can handle a measurable level of throughput. The key is that we need an absolute insane volume of data. We're essentially taking a very high-quality snapshot of the market - and $\mu$s tickers really start to add up.

We can just store this on a generic server PC - the only thing that matters here is the transmission speed at which it can export data. Getting the data can be done with our beloved HiPerGator Supercomputer.

\paragraph {2. A Network Card}\

We need some way to take an exchange protocol (like NASDAQ's ITCH) and parise it into a familiar data stream. This isn't as hard as it sounds.

For moving things between modules we will use the standard AXI-Stream dynamic. Their simple \emph{valid \&\& ready} scheme is effective.

But what about between devices? We aren't about ease of use here; and with speed as a preference, ethernet (and potentially SFP) can easily achieve the speeds on the network card to fanout to our distrbuted system.

We have our faucet turned on and flowing fast through our pipes. 

Time to connect the pipes to something meaningful.

\paragraph {3. Order Book}\ 
Something has to hold the information on the trades from the exchange.
By making use of an arbitrary tier system to tickers we arrive at (2) fundamental core variants.

1. A general dictionary-like core that can store buy/sell orders. By utilizing a hashing system we can store different tickers across multiple different instances of the core for a more scalable approach.A general dictionary-like core that can store buy/sell orders. By utilizing a hashing system we can store different tickers across multiple different instances of the core for a more scalable approach.A general dictionary-like core that can store buy/sell orders. By utilizing a hashing system we can store different tickers across multiple different instances of the core for a more scalable approach.A general dictionary-like core that can store buy/sell orders. By utilizing a hashing system we can store different tickers across multiple different instances of the core for a more scalable approach.

2. A specialized, high-speed core that is specific to a ticker. Because each core is it's own specific ticker, we don't have the latency propagated by the hash computations and can provide a more competitive edge on a subset of favored stocks.


4. Software Interface
We have data from the exchange sitting in our cores. Now we need to do something with them. We need to make decisions. This is where we introduce the concept of \textbf{\emph{rules}}.

An example of a \textbf{rule} may be "buy AAPL if the price drops below 300\$ or more". Who makes up the rules? Not us. That's for the researchers. We're just here to give them somewhere to execute their strategies, and do it fast.

First of all we need to deploy these rules to our systems. The wonderful QSPI system can help us here. This will require some software-software interfacing to configure the fabric constants from a software side, but this shouldn't be too hard.


Another crucial use of our software interface will be logging and risk management.
Logging things in pure hardware \emph{hardly} makes sense, so keeping track of what orders we execute via software is the bare minimum. On top of that we need to manage our risk profiles. Hardware sytsems do exactly what you tell them to. It's just a matter of how fluent you are in the language of the universe.
The FPGA doesn't care if we don't have the capital to wager 700million Norwegian Krone, but we can make it care.

Now the question is, how do we interface software and hardware this close as fast as possible? QSPI is useful for uploading our bitstreams, ethernet requirements PHY layers. PCIe is our solution. GPUs think it's good enough as their main transmission medium so it should be fine for us.

\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Technical Background}

SerDes and >1 Gb Transmission


\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Applications}

\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{Next Steps}

\clearpage
% --------------------------------------------------------


% --------------------------------------------------------
\section*{References}

\clearpage
% --------------------------------------------------------

\end{document}

